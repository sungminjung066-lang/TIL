# 오늘 배운 것

## 자바 스크립트

- [참고자료](https://est-contents.vercel.app/Daily/JavaScript/Features/2.Event)
- [참고자료2](https://wooricodeshare.vercel.app/cc531eb4-1f8a-4e97-b142-6ab6ebea1bf6)
- [참고자료3](https://www.jsv9000.app/)
- [실습사이트](https://app.apidog.com/project/1155556)
- [질문풍선](https://woori-i-zikimi.vercel.app/)

---

## Cookie??

-> 브라우저에 저장되는 Key:value 형태의 값
ex. 다양한 곳에서 활용됨

## Session??

->

세션이 만료되었습니다
-> (로그인했다는 전제 하에) 화면(로그인 페이지)을 유지시키는 시간

---

## In-memory

-> (서버) 프로세스가 실행되는 도중에만 유지되는 성질

메모리(실행 중에만 메모리 공간에 유지) vs 디스크(DB)
피카츄 vs 꼬부기

사용자가 로그인을 성공하여 로그인된 페이지로 이동됨

그 이후 사용자가 내 정보 보기를 누르면

1. 내 정보 보기 페이지가 나온다
2. 다시 로그인하셔야죠가 나온다

---

## HTTP 프로토콜의 특징 중 하나

- Stateless(무상태)

1. 로그인을 성공했다?라는 건 로그인 요청이 수행되었다는 것

POST: /login
id=gugu&pw=1234
-> 그에따라 서버가 "오 너 로그인 성공!"

2. 내 정보보기 요청?? 새로운 HTTP 요청이 발생한 것

GET: /profile (내 정보 보여줘)

-> profile은 로그인된 사용자만 보도록 로직을 구현한 상태라서
서버가 "근데 너 누군데?? 로그인해"라고 동작

세션 트래킹(Session tracking)
-> 세션을 지속적으로 추적하기 위한 전략

세션 트래킹 전략을 통해 사용자가 로그인 성공 후에 내 정보보기를 눌렀을 때, 다시 로그인하라고 하는게 아니라
내 정보를 보여줄 수 있도록 하려면??
(대신, 인증된 사용자 + 인가된 사용자만 볼 수 있다는 건 동일함)

Q. Cookie를 활용하면 가능할 것 같은데??

Hint. 현재 상태
서버에서는 사용자가 인증을 성공해서 sessionId를 생성
'sessionId': { // B5ya123asdvqweasd..
'userId': ddd,
'username': 'ddd',
'createdAt': '1223, 14:44분'
}

1. 사용자의 인증이 성공하면 세션ID를 쿠키로 저장한다.(sessionId: B5ya123asdvqweasd) - 세션(Id)쿠키

- set-cookie 헤더를 활용해서 브라우저에게 쿠키를 전달함

2. 브라우저에서는 사용자가 내 정보보기를 누르면 서버에게 요청을 전송할 때

내 정보보기 요청을 수행할 때, 쿠키를 같이 보냄
-> 기본값으로 같이 보내게됨

3. 그럼 서버는 정보보기 요청이라는 걸 클라이언트에게 받았을 때
   요청 객체에서 헤더를 통해 쿠키를 꺼냄

4. 서버는 세션 저장소에서 클라이언트로부터 받은 쿠키값(SessionId)과 매칭되는 세션 ID를 찾아서
   인증 상태를 확인함

5. 인증이 되어있는 상태면 내 정보보기 페이지를 주는 것

---

## 후기

- 오늘 거는 어느정도 아는 내용도 있어서 그런지 어느정도 알아들을 수 있었다
- 실습 때 헤더 확인 실습을 했는데 완전히 이해한 것은 아니라 챗GPT에게 물어보며 간신히 origin 헤더 확인을 끝냈다.

## 실습 시간에 정리한 것들

- 헤더(Header)
  → 요청/응답에 대한 부가 정보
- 바디(Body)
  → 실제로 주고받는 데이터(JSON 등)
- Origin 헤더는 브라우저가 fetch 요청을 보낼 때 자동으로 추가하는 출처 정보이다. 해당 헤더는 CORS 정책에서 서버가 요청을 허용할지 판단하는 기준으로 사용된다.
